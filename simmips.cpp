// implement entry point for simmips here
#include "lexer.hpp"
#include "parser.hpp"
#include "simulator.hpp"
#include "virtual_machine_gui.hpp"
#include <iostream>
#include <istream> // Input stream objects can read and interpret input from sequences of characters
#include <fstream> // Input/output stream class to operate on files.
#include <cstdlib> // For standard error output
#include <QApplication> // This is to start up the gui

int main(int argc, char *argv[]) // argc: the number of string arguments to the program, argv: an array of ``argc'' C-style strings (pointers to null-terminated memory) with the arguments themselves
{	
	if ((argc != 2) && (argc != 3)) { // fail() will tell if the file exists or not
		cerr << "Error : The number of arguments do not match. Format: simmips.exe FILENAME.asm OR simmips.exe --gui FILENAME.asm" << endl;
		return EXIT_FAILURE;
	}
	else if (argc == 2) { // When User just wants to run the simulator in windows powershell or in GUI but wrote --gui after the assembly file
		ifstream assemblyFile(argv[1]); //Constructs an ifstream object. The Second argument will be the assembly filename 

		if (assemblyFile.fail()) {
			cerr << "Error : Failed to open file" << endl;
			return EXIT_FAILURE;
		}
		else {
			TokenList assemblyTokenList = tokenize(assemblyFile); // tokenizes the assembly file

			if (assemblyTokenList.back().type() == ERROR) {
				cerr << assemblyTokenList.back().value() << endl; // This will output the corresponding error message
				return EXIT_FAILURE;
			}
			else {
				Parser mipsParser(assemblyTokenList); // This constructs a parser called mipsParser that takes the token list generated by the lexer
				mipsParser.parseFile(); // Parses the assemblyTokenList
										// Remember The parser should halt on the first error and the program report only one error
				if (mipsParser.successfullyParsed() == false) {
					cerr << mipsParser.errorMsg() << endl;
					return EXIT_FAILURE;
				}
				else {
					Simulator VirtualMachine(mipsParser.getInitialRegisterContents(), mipsParser.getInitialMemoryLayout(), mipsParser.getProgramInstructions(), mipsParser.getLabelsMap()); // Constructs the basic simulator parameters

					unordered_map<string, LabelInfo> labelMap = mipsParser.getLabelsMap(); // This is to make sure there is a main in the labels map
					unordered_map<string, LabelInfo>::iterator findMain = labelMap.find("main"); // The program counter starts at the main label, so want to find the label name "main"

					if (findMain == labelMap.end()) {
						std::cerr << "Error: There was no main: label found in the .asm file" << endl;
						return EXIT_FAILURE;
					}
					else {
						VirtualMachine.setStartInstrIndex();

						VirtualMachine.simulate();
					}
				}
			}
		}

	}
	else if (argc == 3) {
		string guiPost= argv[2];
		string guiPre = argv[1]; 

		if (guiPre == "--gui" || guiPost == "--gui") {
			QApplication app(argc, argv);
			VirtualMachineGUI vmGui;

			if (guiPost == "--gui")
				vmGui.load(QString(argv[1])); // This will lex, parse and load the specific file into the GUI
			else if (guiPre == "--gui")
				vmGui.load(QString(argv[2])); // This will lex, parse and load the specific file into the GUI
			
			vmGui.guiShow();
			return app.exec();
		}
		else {
			cerr << "Error : There was no --gui command as one of the arguments " << endl;
			return EXIT_FAILURE;
		}
	}

	return EXIT_SUCCESS;
}
